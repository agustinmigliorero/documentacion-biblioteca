<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="./librerias/bootstrap.min.css" />
    <script src="./librerias/bootstrap.bundle.min.js"></script>
    <style>
      body {
        font-size: 1.25em !important;
        font-family: Arial, Helvetica, sans-serif !important;
      }

      p {
        text-align: justify;
      }

      pre {
        color: #eeeeee;
        padding: 5px;
        border-radius: 3px;
        background-color: #2b2b2b;
      }
      
    </style>
  </head>
  <body>
    <h1 style="text-align: center" class="mb-5">Documentación del sistema</h1>
    <div class="container">
      <div class="row">
        <div class="col-sm-3 col-12">
          <ul>
            <li><a href="#servidor">Servidor</a></li>
            <ul>
              <li><a href="#modelos">Modelos</a></li>
                <ul>
                    <li><a href="#modelo-usuario">Usuario</a></li>
                    <li><a href="#modelo-libro">Libro</a></li>
                    <li><a href="#modelo-comentario">Comentario</a></li>
                    <li><a href="#modelo-prestamo">Prestamo</a></li>
                    <li><a href="#modelo-reserva">Reserva</a></li>
                </ul>
              <li><a href="#controladores">Controladores</a></li>
              <ul>
                <li><a href="#controlador-usuario">Controladores Usuario</a></li>
                <ul>
                    <li><a href="#controlador-usuario-crearUsuario">crearUsuario</a></li>
                    <li><a href="#controlador-usuario-buscarUsuario">buscarUsuario</a></li>
                    <li><a href="#controlador-usuario-verUsuarios">verUsuarios</a></li>
                    <li><a href="#controlador-usuario-editarUsuario">editarUsuario</a></li>
                    <li><a href="#controlador-usuario-eliminarUsuario">eliminarUsuario</a></li>
                    <li><a href="#controlador-usuario-loginUsuario">loginUsuario</a></li>
                    <li><a href="#controlador-usuario-desconectarUsuario">desconectarUsuario</a></li>
                    <li><a href="#controlador-usuario-usuarioLogeado">usuarioLogeado</a></li>
                    <li><a href="#controlador-usuario-errorLogin">errorLogin</a></li>
                </ul>

                <li><a href="#controlador-libro">Controladores Libro</a></li>
                <ul>
                    <li><a href="#controlador-libro-crearLibro">crearLibro</a></li>
                    <li><a href="#controlador-libro-buscarLibro">buscarLibro</a></li>
                    <li><a href="#controlador-libro-verLibros">verLibros</a></li>
                    <li><a href="#controlador-libro-editarLibro">editarLibro</a></li>
                    <li><a href="#controlador-libro-eliminarLibro">eliminarLibro</a></li>
                </ul>
                <li><a href="#controlador-comentario">Controladores Comentario</a></li>
                <ul>
                  <li><a href="#controlador-comentarios-crearComentario">crearComentario</a></li>
                  <li><a href="#controlador-comentarios-verComentario">verComentario</a></li>
                  <li><a href="#controlador-comentarios-modificarComentario">modificarComentario</a></li>
                  <li><a href="#controlador-comentarios-eliminarComentario">eliminarComentario</a></li>
                </ul>
                <li><a href="#controlador-reserva">Controladores Reserva</a></li>
                <ul>
                    <li><a href="#controlador-reserva-crearReserva">crearReserva</a></li>
                    <li><a href="#controlador-reserva-verReserva">verReserva</a></li>
                    <li><a href="#controlador-reserva-verReservas">verReservas</a></li>
                    <li><a href="#controlador-reserva-editarReserva">editarReserva</a></li>
                    <li><a href="#controlador-reserva-eliminarReserva">eliminarReserva</a></li>
                </ul>
                <li><a href="#controlador-prestamo">Controladores Prestamo</a></li>
                <ul>
                    <li><a href="#controlador-prestamo-crearPrestamo">crearPrestamo</a></li>
                    <li><a href="#controlador-prestamo-verPrestamo">verPrestamo</a></li>
                    <li><a href="#controlador-prestamo-verPrestamos">verPrestamos</a></li>
                    <li><a href="#controlador-prestamo-editarPrestamo">editarPrestamo</a></li>
                    <li><a href="#controlador-prestamo-eliminarPrestamo">eliminarPrestamo</a></li>
                </ul>
              </ul>
              <li><a href="#rutas">Rutas</a></li>
              <ul>
                <li><a href="#rutas-usuario">Rutas Usuario</a></li>
                <li><a href="#rutas-libro">Rutas Libro</a></li>
                <li><a href="#rutas-comentario">Rutas Comentario</a></li>
                <li><a href="#rutas-reserva">Rutas Reserva</a></li>
                <li><a href="#rutas-prestamo">Rutas Prestamo</a></li>
              </ul>
              <li><a href="#esquemas-validaciones">Esquemas para Validaciones</a></li>
              <ul>
                <li><a href="#esquemas-esquemaUsuario">esquemaUsuario</a></li>
                <li><a href="#esquemas-esquemaEditarUsuario">esquemaEditarUsuario</a></li>
                <li><a href="#esquemas-esquemaLibro">esquemaLibro</a></li>
                <li><a href="#esquemas-esquemaModificarLibro">esquemaModificarLibro</a></li>
                <li><a href="#esquemas-esquemaComentario">esquemaComentario</a></li>
                <li><a href="#esquemas-esquemaModificarComentario">esquemaModificarComentario</a></li>
                <li><a href="#esquemas-esquemaReserva">esquemaReserva</a></li>
                <li><a href="#esquemas-esquemaEditarReserva">esquemaEditarReserva</a></li>
                <li><a href="#esquemas-esquemaPrestamo">esquemaPrestamo</a></li>
                <li><a href="#esquemas-esquemaEditarPrestamo">esquemaEditarPrestamo</a></li>
              </ul>
            </ul>
            <li>Cliente</li>
            <ul>
              <li>Paginas</li>
              <ul>
                <li>Inicio</li>
                <li>Usuarios</li>
                <ul></ul>
                <li>Libros</li>
                <li>Reservas</li>
                <li>Prestamos</li>
              </ul>
              <li>Componentes</li>
              <li>Utils</li>
            </ul>
            
            
          </ul>
        </div>
        <div class="col-sm-9 col-12">
          <p>
            El siguiente es un sistema de biblioteca diseñado en el marco la
            materia de Practicas Profesionalizantes de 1er año de la carrera de
            tecnicatura superior de análisis de sistemas del instituto superior
            de formación docente y técnica N° 2.
          </p>
          <p>
            Para el proyecto se decidió por un patrón de diseño de software de
            tipo MVC (Modelo, Vista, Controlador). El modelo se encarga de
            manejar los datos y lógica de negocios, las vistas se encargan del
            diseño y presentación desde el lado del cliente y los controladores
            contiene la lógica que actualiza el modelo y las vistas dependiendo
            del tipo de petición que realice el usuario.
<br><br>
            Link al repositorio: <b><a href="https://github.com/agustinmigliorero/Biblioteca-Practicas-Profesionalizantes">Repositorio GitHub</a></b>
          </p>
          <h2 class="mt-4">Tecnologías usadas en el proyecto</h2>
          <hr>
          <h3 class="mt-3">Servidor:</h3>
          <ul>
            <li>
              <b>NodeJS:</b> Es un entorno que permite ejecutar codigo
              JavaScript desde el lado del servidor.
            </li>
            <li><b>Express:</b> Es un framework para NodeJS utilizado para facilitar la creacion de aplicaciones web y APIs</li>
            <li>
              <b>MongoDB:</b> Es un sistema de base de datos NoSQL, orientado a modelos y documentos.
            </li>
            <li>
              <b>Mongoose:</b> Es una libreria que facilita la interaccion desde el servidor con la base de datos mediante esquemas.
            </li>
            <li><b>Passport:</b> Es una libreria diseñada para Express que permite implementar la autenticacion de usuarios con contraseñas encriptadas, ademas de ofrecer distintos metodos de registro.</li>
            <li>
              <b>Joi:</b> Es una libreria que permite realizar validaciones desde el lado del servidor.
            </li>
            <li>
              <b>Body Parser:</b> Es una librería de NodeJS utilizada para
              formatear la información recibida por el servidor de formato JSON
              a JavaScript.
            </li>
            
            <li>
              <b>Express Session:</b> Utilizado para mantener y almacenar las sesiones en el navegador de los clientes.
            </li>

          </ul>
          
          <p>
            Links a sus documentaciones: <a href="https://nodejs.org/en" target="_blank">NodeJS</a>, <a href="https://expressjs.com/es/" target="_blank">Express</a>, <a href="https://www.mongodb.com/es" target="_blank">MongoDB</a>, <a href="https://mongoosejs.com/" target="_blank">Mongoose</a>,  <a href="https://www.passportjs.org/" target="_blank">PassportJS</a>,  <a href="https://joi.dev/" target="_blank">Joi</a>, <a href="https://www.npmjs.com/package/body-parser" target="_blank">Body Parser</a>, <a href="https://www.npmjs.com/package/express-session" target="_blank">Express Session</a>
          </p>
          <h3 class="mt-3">Cliente:</h3>
          <ul>
            <li>
              <b>Vite:</b> Es una herramienta utilizada para crear un entorno de desarrollo web, en este caso se utilizo para el cliente con React.
            </li>
            <li>
              <b>ReactJS:</b> Es una biblioteca Javascript de código abierto diseñada para crear interfaces de usuario con el objetivo de facilitar el desarrollo de aplicaciones en una sola página (SPA) mediante la creacion de componentes.
            </li>
            <li>
              <b>React Router:</b> Es una librería de enrutamiento construida sobre React que nos va a permitir crear rutas dinamicas de manera sencilla.
            </li>
            <li>
              <b>Bootstrap:</b>
              Es una librería de CSS que otorga estilos prediseñados para facilitar la creacion de interfaces.
            </li>
          </ul>
          <p>
            Links a sus documentaciones: <a href="https://vitejs.dev" target="_blank">Vite</a>, <a href="https://reactjs.org" target="_blank">ReactJS</a>, <a href="https://reactrouter.com/en/main" target="_blank">React Router</a>, <a href="https://getbootstrap.com" target="_blank">Bootstrap</a>
          </p>
          

          <h1 id="servidor" class="mt-5">Servidor:</h1>
          <hr>
          <h2 id="modelos" class="mt-4">Modelos</h2>
          <p>Los modelos son la estructura que indica cual es la forma en la que están estructurados los documentos que se almacenan en una colección de documentos.</p>
          <h3 id="modelo-usuario" class="mt-3">Modelo Usuario</h3>
          <p>
            El siguiente código define un esquema/clase de Mongoose para el
            modelo "Usuario" en una base de datos de MongoDB.
          </p>
          <pre>
<code>const mongoose = require("mongoose");
const Schema = mongoose.Schema;
const passportLocalMongoose = require("passport-local-mongoose");

// MODELO DE LA CLASE USUARIO EN LA BASE DE DATOS
const usuarioSchema = new Schema(
  {
    dni: { type: Number },
    nombre: { type: String },
    apellido: { type: String },
    email: { type: String },
    rol: { default: "Estudiante", type: String },
    activo: { type: Boolean, default: false },
    comentarios: [{ type: Schema.Types.ObjectId, ref: "Comentario" }],
    prestamos: [{ type: Schema.Types.ObjectId, ref: "Prestamo" }],
    reservas: [{ type: Schema.Types.ObjectId, ref: "Reserva" }],
  },
  {
    timestamps: true,
  }
);

usuarioSchema.plugin(passportLocalMongoose); // PLUGIN DE PASSPORT PARA AUTENTICAR USUARIOS

module.exports = mongoose.model("Usuario", usuarioSchema);</code>
          </pre>

          
          <p>
            Propiedades:
            <ul>
                <li><b>dni:</b> DNI del usuario.</li>
                <li><b>nombre:</b> Nombre del usuario.</li>
                <li><b>apellido:</b> Apellido del usuario.</li>
                <li><b>email:</b> Email del usuario.</li>
                <li><b>rol:</b> Rol del usuario (por defecto, "Estudiante").</li>
                <li><b>activo:</b> Estado de actividad del usuario (por defecto, false).</li>
                <li><b>comentarios:</b> Array de referencias a comentarios hechos por el usuario.</li>
                <li><b>prestamos:</b> Array de referencias a préstamos hechos por el usuario.</li>
                <li><b>reservas:</b> Array de referencias a reservas hechas por el usuario</li>
            </ul>
          </p>

          <hr>

          <h3 id="modelo-libro" class="mt-4">Modelo Libro</h3>

          <p>
            El siguiente código define un esquema/clase de Mongoose para el
            modelo "Libro" en una base de datos de MongoDB.
          </p>

<pre><code>const mongoose = require("mongoose");
const prestamo = require("./prestamo");
const Schema = mongoose.Schema;

const schemaLibro = new Schema({
    titulo: { type: String },
    autor: { type: String },
    categoria: { type: String },
    copiaVirtual: { type: String }, // url de la copia virtual
    copiasLibro: { type: Number },
    comentarios: [{ type: Schema.Types.ObjectId, ref: "Comentario" }], // array de comentarios
    descripcion: { type: String },
    imagen: { type: String },
    reservas: [{ type: Schema.Types.ObjectId, ref: "Reserva" }],
    prestamos: [{ type: Schema.Types.ObjectId, ref: "Prestamo" }],
});

module.exports = mongoose.model("Libro", schemaLibro);</code></pre>

<p>
    Propiedades:
<ul>
    <li><b>titulo</b> Título del libro.</li>
    <li><b>autor:</b> Autor del libro.</li>
    <li><b>categoria:</b> Categoría del libro.</li>
    <li><b>copiaVirtual:</b> URL de la copia virtual del libro.</li>
    <li><b>copiasLibro:</b> Número de copias disponibles.</li>
    <li><b>comentarios:</b> Array de referencias a comentarios asociados al libro.</li>
    <li><b>descripcion:</b> Descripción del libro.</li>
    <li><b>imagen:</b> URL de la imagen del libro.</li>
    <li><b>reservas:</b> Array de referencias a reservas asociadas al libro.</li>
    <li><b>prestamos:</b> Array de referencias a préstamos asociados al libro.</li>
</ul>
</p>
<hr>

<h3 id="modelo-comentario" class="mt-4">Modelo Comentario</h3>

<p>
    El siguiente código define un esquema/clase de Mongoose para el
    modelo "Comentario" en una base de datos de MongoDB.
</p>

<pre><code>const moongose = require("mongoose");
const Schema = moongose.Schema;

const schemaPrestamo = new Schema({
    idLibro: { type: Schema.Types.ObjectId, ref: "Libro" },
    documento: { type: Schema.Types.ObjectId, ref: "Usuario" },
    fechaDeInicio: { type: Date },
    fechaDeFin: { type: Date },
    fechaDevolucion: { type: Date },
});

module.exports = moongose.model("Prestamo", schemaPrestamo);</code></pre>

<p>
    Propiedades:
<ul>
    <li><b>titulo:</b> Título del libro.</li>
    <li><b>autor:</b> Autor del libro.</li>
    <li><b>categoria:</b> Categoría del libro.</li>
    <li><b>copiaVirtual:</b> URL de la copia virtual del libro.</li>
    <li><b>copiasLibro:</b> Número de copias disponibles.</li>
    <li><b>comentarios:</b> Array de referencias a comentarios asociados al libro.</li>
    <li><b>descripcion:</b> Descripción del libro.</li>
    <li><b>imagen:</b> URL de la imagen del libro.</li>
    <li><b>reservas:</b> Array de referencias a reservas asociadas al libro.</li>
    <li><b>prestamos:</b> Array de referencias a préstamos asociados al libro.</li>
</ul>
</p>

<hr>

<h3 id="modelo-prestamo" class="mt-4">Modelo Prestamo</h3>

<p>
    El siguiente código define un esquema/clase de Mongoose para el
    modelo "Prestamo" en una base de datos de MongoDB.
</p>

<pre><code>const moongose = require("mongoose");
const Schema = moongose.Schema;

const schemaPrestamo = new Schema({
    idLibro: { type: Schema.Types.ObjectId, ref: "Libro" },
    documento: { type: Schema.Types.ObjectId, ref: "Usuario" },
    fechaDeInicio: { type: Date },
    fechaDeFin: { type: Date },
    fechaDevolucion: { type: Date },
});

module.exports = moongose.model("Prestamo", schemaPrestamo);</code></pre>

<p>
    Propiedades:
    <ul>
        <li><b>idLibro:</b> Referencia al libro prestado.</li>
        <li><b>documento:</b> Referencia al usuario que hizo el préstamo.</li>
        <li><b>fechaDeInicio:</b> Fecha de inicio del préstamo.</li>
        <li><b>fechaDeFin:</b> Fecha de fin del préstamo.</li>
        <li><b>fechaDevolucion:</b> Fecha de devolución del libro.</li>
    </ul>
</p>

<hr>

<h3 id="modelo-reserva" class="mt-4">Modelo Reserva</h3>
<p>
    El siguiente código define un esquema/clase de Mongoose para el
    modelo "Reserva" en una base de datos de MongoDB.
</p>

<pre><code>const moongose = require("mongoose");
const Schema = moongose.Schema;

const schemaReserva = new Schema({
    documento: { type: Schema.Types.ObjectId, ref: "Usuario" },
    idLibro: { type: Schema.Types.ObjectId, ref: "Libro" },
    fechaReserva: { type: Date },
    fechaDevolucion: { type: Date },
    estadoReserva: { type: Boolean, default: true },
});

module.exports = moongose.model("Reserva", schemaReserva);</code></pre>

<p>
    Propiedades:
    <ul>
        <li><b>documento:</b> Referencia al usuario que hizo la reserva.</li>
        <li><b>idLibro:</b> Referencia al libro reservado.</li>
        <li><b>fechaReserva:</b> Fecha de la reserva.</li>
        <li><b>fechaDevolucion:</b> Fecha de devolución de la reserva.</li>
        <li><b>estadoReserva:</b> Estado de la reserva (por defecto, true).</li>
    </ul>
</p>

<hr>

<h2 id="controladores" class="mt-4">Controladores</h2>
<hr>
<p>Uno de los elementos más importantes en un Servidor con una API REST hecha con NodeJS y ExpressJS es la creación de los controladores. Los controladores son responsables de procesar las solicitudes y respuestas del servidor, facilitando la comunicación entre el Cliente y el Servidor</p>
<p>En los controladores se van a repetir frecuentemente los siguientes terminos, asi que vamos a explicarlos un poco.</p>
<ul>
  <li><b>req.body:</b> Este es un objeto dentro de la peticion que contiene los datos enviados desde el cliente en el cuerpo de la peticion HTTP (generalmente una solicitud POST/PUT)</li>
  <li><b>req.params:</b> Es una propiedad de la peticion que nos permite capturar parametros o valores dinamicos de la URL.</li>
</ul>

<p><b>Async/Await</b>: El uso de async y await en JavaScript se utiliza para escribir código asíncrono de una manera más limpia y fácil de leer.</p>
<p>La palabra clave async se utiliza antes de una función para indicar que esa función retornará una Promesa. Esto permite que la función se comporte de manera asíncrona, incluso si contiene operaciones sincrónicas y/o asíncronas. Cuando una función es declarada como async, automáticamente devuelve una Promesa.</p>
<p>La palabra clave await se utiliza dentro de una función async para esperar a que una Promesa se resuelva antes de continuar con la ejecución del código. Esto significa que cuando se encuentra la palabra clave await, la ejecución del código se pausa hasta que la Promesa se resuelva, y luego se reanuda con el valor resuelto de la Promesa.</p>

<hr>
<h2 id="controlador-usuario" class="mt-4">Controladores de Usuario</h2>
<p>En este apartado se definen los controladores para el manejo de los usuarios.</p>
<hr>
<h3 id="controlador-usuario-crearUsuario" class="mt-4">Controlador crearUsuario</h3>
<p>El siguiente código define una función crearUsuario que maneja la creación de un nuevo usuario en la aplicación.</p>
<pre><code>const crearUsuario = async (req, res) => {
// METODO PARA CREAR UN NUEVO USUARIO
  const { dni, nombre, apellido, email, password } = req.body; // SE OBTIENEN LOS DATOS DEL CUERPO DE LA PETICION
  const usuario = new Usuario({
    dni,
    nombre,
    apellido,
    email,
    password,
    username: dni,
  });

  const nuevoUsuario = await Usuario.register(usuario, password);

  const usuarioCreado = await Usuario.findOne({ username: dni });

  req.login(usuarioCreado, (err) => {
    if (err) {
      return next(err);
    }
    res.json({ logeado: true, usuario: nuevoUsuario });
  });
};</code></pre>
<p>En resumen el código anterior maneja la creación de un nuevo usuario en la base de datos, luego registra y autentica al usuario creado. Finalmente, envía una respuesta en formato JSON con el estado de inicio de sesión y los detalles del usuario recién creado.</p>
<hr>
<h3 id="controlador-usuario-buscarUsuario" class="mt-4">Controlador buscarUsuario</h3>
<p>El siguiente código define una función buscarUsuario que maneja la buqueda de un usuario en la aplicación.</p>
<pre><code>const buscarUsuario = async (req, res) => {
  const { id } = req.params;
  const usuario = await Usuario.findById(id)
    .populate({
      path: "comentarios",
      populate: { path: "idLibro" },
    })
    .populate({ path: "reservas", populate: { path: "idLibro" } })
    .populate({ path: "prestamos", populate: { path: "idLibro" } });
  res.json(usuario);
};</code></pre>
<p>En resumen, este código busca un usuario en la base de datos utilizando el ID proporcionado, luego rellena los campos relacionados del usuario con los documentos correspondientes en otras colecciones de la base de datos (comentarios, reservas y prestamos) y finalmente envía una respuesta JSON con el objeto del usuario encontrado.</p>

<hr>
<h3 id="controlador-usuario-verUsuarios" class="mt-4">Controlador verUsuarios</h3>
<p>El siguiente código define una función verUsuarios que maneja la consulta de todos los usuarios en la base de datos y devuelve una respuesta JSON con la lista de usuarios encontrados.</p>
<pre><code>const verUsuarios = async (req, res) => {
  const usuarios = await Usuario.find();
  res.json(usuarios);
};</code></pre>
<p>En resumen, este código busca y recupera todos los usuarios almacenados en la base de datos utilizando el modelo Usuario y luego envía una respuesta JSON con la lista de usuarios encontrados.</p>

<hr>
<h3 id="controlador-usuario-editarUsuario" class="mt-4">Controlador editarUsuario</h3>
<p>El siguiente código define una función editarUsuario que maneja la actualización de un usuario en la base de datos.</p>
<pre><code>const editarUsuario = async (req, res) => {
  const { id } = req.params;
  const { nombre, apellido, email, password, rol, activo } = req.body;
  const usuario = await Usuario.findByIdAndUpdate(id, {
    nombre,
    apellido,
    email,
    password,
    rol,
    activo,
  });
  res.json({ mensaje: "Usuario actualizado", usuario });
};</code></pre>
<p>En resumen, este código busca un usuario en la base de datos utilizando el ID proporcionado en los parametros de la URL, luego actualiza los campos del usuario con los nuevos datos extraidos del cuerpo de la peticion y finalmente envía una respuesta JSON con un mensaje de confirmación y el objeto del usuario actualizado.</p>

<hr>
<h3 id="controlador-usuario-eliminarUsuario" class="mt-4">Controlador eliminarUsuario</h3>
<p>El siguiente código define una función eliminarUsuario que se encarga de eliminar un usuario de la base de datos, así como también eliminar los comentarios y reservas asociados a ese usuario.</p>
<pre><code>const eliminarUsuario = async (req, res) => {
  const { id } = req.params;
  const usuario = await Usuario.findByIdAndDelete(id);
  await Comentario.deleteMany({ documento: id });
  await Reserva.deleteMany({ documento: id });
  res.json({ mensaje: "Usuario eliminado", usuario });
};</code></pre>
<p>En resumen, este código elimina un usuario de la base de datos, también elimina los comentarios y reservas asociados a ese usuario utilizando el metodo deleteMany. Luego envía una respuesta JSON confirmando la eliminación del usuario.</p>

<hr>
<h3 id="controlador-usuario-loginUsuario" class="mt-4">Controlador loginUsuario</h3>
<p>Este código define una función loginUsuario que maneja la notificacion de inicio de sesión de un usuario.</p>
<pre><code>const loginUsuario = async (req, res) => {
  const { username } = req.body;
  const usuario = await Usuario.findOne({ username });
  res.json({ logeado: true, usuario: usuario });
};</code></pre>
<p>En resumen, este código busca un usuario en la base de datos basándose en el nombre de usuario proporcionado en la solicitud de inicio de sesión (username/DNI), y luego envía una respuesta JSON indicando que el usuario ha iniciado sesión correctamente, junto con los datos del usuario encontrado.</p>
<p>Nota: Esta funcion solamente maneja la notificacion de inicio de sesión de un usuario y le envia al cliente la informacion del usuario logeado en formato JSON, pero no se encarga de la autenticación del usuario, este proceso se realiza antes desde las rutas usando la libreria PassportJS.</p>

<hr>
<h3 id="controlador-usuario-desconectarUsuario" class="mt-4">Controlador desconectarUsuario</h3>
<p>Este código define una función desconectarUsuario que maneja la desconexión de un usuario con un inicio de sesion activo.</p>
<pre><code>const desconectarUsuario = async (req, res) => {
  req.logout(function (err) {
    if (err) {
      return next(err);
    }
    res.json({ logeado: false });
  });
};</code></pre>
<p>En resumen, este código finaliza la sesión del usuario utilizando el método logout de la libreria PassportJS y envía una respuesta JSON indicando que el usuario ha sido desconectado correctamente.</p>

<hr>
<h3 id="controlador-usuario-usuarioLogeado" class="mt-4">Controlador usuarioLogeado</h3>
<p>Este código define una función usuarioLogeado que maneja la verificación de si un usuario está actualmente autenticado con una sesion activa o no.</p>
<pre><code>const usuarioLogeado = async (req, res) => {
  if (req.user) {
    res.json({ logeado: true, usuario: req.user });
  } else {
    res.json({ logeado: false });
  }
};</code></pre>
<p>En resumen, este código verifica si el usuario está autenticado o no utilizando el objeto req.user proporcionado por PassportJS. Si el usuario está autenticado, envía una respuesta JSON indicando que el usuario está autenticado y devuelve los datos del usuario autenticado. Si el usuario no está autenticado, envía una respuesta JSON indicando que el usuario no está autenticado.</p>

<hr>
<h3 id="controlador-usuario-errorLogin" class="mt-4">Controlador errorLogin</h3>
<p>Este código define una función errorLogin que maneja la notificacion de error de inicio de sesión de un usuario.</p>
<pre><code>const errorLogin = async (req, res) => {
  res.status(401).json({ error: true, msg: "Usuario o contraseña incorrecta" });
};</code></pre>
<p>En resumen, este código envía una respuesta JSON con un error indicando que el usuario o la contraseña son incorrectas.</p>
<p>Nota: Al igual que el controlador loginUsuario, esta funcion solamente maneja la notificacion de error de inicio de sesión de un usuario y le envia al cliente el error en formato JSON, pero no se encarga de la autenticación del usuario, este proceso se realiza antes desde las rutas usando la libreria PassportJS.</p>

<hr>

<h2 id="controlador-libro" class="mt-4">Controladores de Libro</h2>
<p>En este apartado se definen los controladores para el manejo de los libros.</p>

<hr>

<h3 id="controlador-libro-crearLibro" class="mt-4">Controlador crearLibro</h3>
<p>Este código define una función crearLibro que se encarga de crear un nuevo libro en la base de datos.</p>
<pre><code>const crearLibro = async (req, res) => {
  const {
    titulo,
    autor,
    categoria,
    copiaVirtual,
    copiasLibro,
    descripcion,
    imagen,
    //copiasDisponibles,
  } = req.body;
  const libro = new Libro({
    titulo,
    autor,
    categoria,
    copiaVirtual,
    copiasLibro,
    descripcion,
    imagen,
    //copiasDisponibles,
  });
  await libro.save();
  res.json({ mensaje: "Libro creado" });
};</code></pre>

<p>En resumen, este código recibe los datos de un nuevo libro en la peticion del cliente, crea un documento de libro con esos datos, lo guarda en la base de datos y luego responde con un mensaje indicando que el libro ha sido creado con éxito.</p>

<hr>
<h3 id="controlador-libro-buscarLibro" class="mt-4">Controlador buscarLibro</h3>
<p>Este código define una función buscarLibro que se encarga de buscar un libro en la base de datos utilizando su ID y devolver los datos del libro, así como también los comentarios y reservas asociados a ese libro.</p>
<pre><code>const buscarLibro = async (req, res) => {
  const { id } = req.params;
  const libro = await Libro.findById(id)
    .populate({
      path: "comentarios",
      populate: { path: "documento" },
    })
    .populate({ path: "reservas", populate: { path: "documento" } });
  res.json(libro);
};</code></pre>
<p>En resumen, este código busca un libro en la base de datos utilizando su ID, esta llega desde los parametros de la peticion en la URL, luego carga los comentarios y reservas con los datos correspondientes y termina enviando una respuesta JSON con los datos del libro, incluyendo los comentarios y reservas asociados.</p>

<hr>
<h3 id="controlador-libro-verLibros" class="mt-4">Controlador verLibros</h3>
<p>Este código define una función verLibros que se encarga de obtener todos los libros de la base de datos y devolverlos en una respuesta JSON.</p>
<pre><code>const verLibros = async (req, res) => {
  const libros = await Libro.find();
  res.json(libros);
};</code></pre>
<p>En resumen, este código obtiene todos los libros de la base de datos utilizando el método find del modelo Libro y luego envía una respuesta JSON con los datos de todos los libros.</p>

<hr>
<h3 id="controlador-libro-modificarLibro" class="mt-4">Controlador modificarLibro</h3>
<p>Este código define una función modificarLibro que se encarga de actualizar los datos de un libro en la base de datos</p>
<pre><code>const modificarLibro = async (req, res) => {
  const { id } = req.params;
  const {
    titulo,
    autor,
    categoria,
    copiaVirtual,
    copiasLibro,
    descripcion,
    imagen,
    //copiasDisponibles,
  } = req.body;
  const libro = await Libro.findByIdAndUpdate(id, {
    titulo,
    autor,
    categoria,
    copiaVirtual,
    copiasLibro,
    descripcion,
    imagen,
    //copiasDisponibles,
  });
  res.json({ mensaje: "Libro modificado", libro });
};</code></pre>
<p>En resumen, este código permite modificar un libro en la base de datos. Utiliza la ID proporcionada en los parametros de la peticion (URL) para buscarlo, y luego usa los nuevos datos enviados en la solicitud HTTP para modificarlo. Termina respondiendo con un mensaje de éxito y el libro actualizado.</p>

<hr>
<h3 id="controlador-libro-eliminarLibro" class="mt-4">Controlador eliminarLibro</h3>
<p>Este código define una función eliminarLibro que se encarga de eliminar un libro de la base de datos.</p>
<pre><code>const eliminarLibro = async (req, res) => {
  const { id } = req.params;
  const libro = await Libro.findByIdAndDelete(id);
  res.json({ mensaje: "Libro eliminado", libro });
};</code></pre>
<p>En resumen, este código elimina un libro de la base de datos utilizando el ID proporcionado en los parametros de la peticion (URL) y luego responde con un mensaje indicando que el libro ha sido eliminado exitosamente, junto con los datos del libro eliminado.</p>

<hr>
<h2 id="controlador-comentario" class="mt-4">Controladores de Comentario</h2>
<p>En este apartado se definen los controladores para el manejo de los comentarios.</p>

<hr>
<h3 id="controlador-comentarios-crearComentario" class="mt-4">Controlador crearComentario</h3>
<p>Este código define una función crearComentario que se encarga de crear un nuevo comentario y asociarlo a un libro y a un usuario en la base de datos.</p>
<pre><code>const crearComentario = async (req, res) => {
  const { idLibro, documento, textoComentario, puntuacion } = req.body;
  const comentario = new Comentario({
    idLibro,
    documento,
    textoComentario,
    puntuacion,
  });
  await comentario.save();
  await Libro.findByIdAndUpdate(idLibro, {
    $push: { comentarios: comentario._id },
  });
  await Usuario.findByIdAndUpdate(documento, {
    $push: { comentarios: comentario._id },
  });
  res.json({ mensaje: "Comentario creado", comentario });
};</code></pre>
<p>En resumen, este código crea un nuevo comentario que acepta un texto y una puntuacion en la base de datos, asocia el comentario creado al libro y al usuario correspondientes, y luego responde con un mensaje de éxito y los datos del comentario creado.</p>

<hr>
<h3 id="controlador-comentarios-verComentario" class="mt-4">Controlador verComentario</h3>
<p>Este código define una función verComentario que se encarga de obtener un comentario específico de la base de datos mediante su ID y devolverlo en una respuesta JSON.</p>
<pre><code>const verComentario = async (req, res) => {
  const { id } = req.params;
  const comentario = await Comentario.findById(id);
  res.json(comentario);
};</code></pre>
<p>En resumen, este código obtiene un comentario específico de la base de datos utilizando el ID proporcionado en los parametros de la peticion (URL), y luego envía una respuesta JSON con los datos de ese comentario.</p>

<hr>
<h3 id="controlador-comentarios-modificarComentario" class="mt-4">Controlador modificarComentario</h3>
<p>Este código define una función modificarComentario que se encarga de actualizar los datos de un comentario en la base de datos.</p>
<pre><code>const modificarComentario = async (req, res) => {
  const { id } = req.params;
  const { textoComentario, puntuacion } = req.body;
  const comentario = await Comentario.findByIdAndUpdate(id, {
    textoComentario,
    puntuacion,
  });
  res.json({ mensaje: "Comentario modificado", comentario });
};</code></pre>
<p>En resumen, este código permite modificar un comentario en la base de datos utilizando el ID proporcionado en los parametros de la peticion (URL) junto a los nuevos datos enviados en la solicitud HTTP, y luego responde con un mensaje de éxito y los datos actualizados del comentario.</p>

<hr>
<h3 id="controlador-comentarios-eliminarComentario" class="mt-4">Controlador eliminarComentario</h3>
<p>Este código define una función eliminarComentario que se encarga de eliminar un comentario de la base de datos y actualizar los arrays de libros y usuarios relacionados.</p>
<pre><code>const eliminarComentario = async (req, res) => {
  const { id } = req.params;
  const comentario = await Comentario.findByIdAndDelete(id);
  await Libro.findByIdAndUpdate(comentario.idLibro, {
    $pull: { comentarios: id },
  });
  await Usuario.findByIdAndUpdate(comentario.documento, {
    $pull: { comentarios: id },
  });
  res.json({ mensaje: "Comentario eliminado", comentario });
};</code></pre>
<p>En resumen, este código elimina un comentario de la base de datos utilizando el ID proporcionado en los parametros de la peticion (URL), actualiza los datos relacionados en los libros y usuarios eliminando el ID del comentario de los arrays de comentarios correspondientes en cada documento, y luego responde con un mensaje de éxito y los datos del comentario eliminado.</p>

<hr>
<h2 id="controlador-comentario" class="mt-4">Controladores de Reserva</h2>
<p>En este apartado se definen los controladores para el manejo de las reservas.</p>

<hr>
<h3 id="controlador-reserva-crearReserva" class="mt-4">Controlador crearReserva</h3>
<p>Este código define una función crearReserva que se encarga de crear una nueva reserva de un libro en la base de datos y asociar esta reserva tanto al libro como al usuario correspondientes.</p>
<pre><code>const crearReserva = async (req, res) => {
  const { idLibro, documento, fechaReserva, fechaDevolucion, estadoReserva } =
    req.body;

  const reserva = new Reserva({
    idLibro,
    documento,
    fechaReserva,
    fechaDevolucion,
    estadoReserva,
  });
  await reserva.save();
  await Libro.findByIdAndUpdate(idLibro, {
    $push: { reservas: reserva._id },
  });
  await Usuario.findByIdAndUpdate(documento, {
    $push: { reservas: reserva._id },
  });
  res.json({ mensaje: "Reserva creada" });
};</code></pre>
<p>En resumen, este código crea una nueva reserva de un libro en la base de datos, asocia la reserva tanto al libro como al usuario correspondientes mediante la actualización de sus respectivos arrays de reservas, y luego responde con un mensaje indicando que la reserva ha sido creada satisfactoriamente.</p>

<hr>
<h3 id="controlador-reserva-verReserva" class="mt-4">Controlador verReserva</h3>
<p>Este código define una función verReserva que se encarga de buscar y devolver una reserva específica de la base de datos.</p>
<pre><code>const verReserva = async (req, res) => {
  const { id } = req.params;
  const reserva = await Reserva.findById(id);
  res.json(reserva);
};</code></pre>
<p>En resumen, este código busca una reserva en la base de datos utilizando el ID proporcionado en la URL de la petición HTTP, la encuentra y la devuelve en forma de respuesta JSON.</p>

<hr>
<h3 id="controlador-reserva-verReservas" class="mt-4">Controlador verReservas</h3>
<p>Este código define una función verReservas que se encarga de buscar y devolver todas las reservas en la base de datos.</p>
<pre><code>const verReservas = async (req, res) => {
  const reservas = await Reserva.find();
  res.json(reservas);
};</code></pre>
<p>En resumen, este código busca todas las reservas en la base de datos y las devuelve en forma de respuesta JSON.</p>

<hr>
<h3 id="controlador-reserva-editarReserva" class="mt-4">Controlador editarReserva</h3>
<p>Este código define una función editarReserva que se encarga de modificar una reserva existente en la base de datos.</p>
<pre><code>const editarReserva = async (req, res) => {
  const { id } = req.params;
  const { idLibro, documento, fechaReserva, fechaDevolucion, estadoReserva } =
    req.body;
  const reserva = await Reserva.findByIdAndUpdate(id, {
    idLibro,
    documento,
    fechaReserva,
    fechaDevolucion,
    estadoReserva,
  });
  res.json({ mensaje: "Reserva modificada", reserva });
};</code></pre>
<p>En resumen, este código busca una reserva en la base de datos utilizando el ID proporcionado en la URL de la petición HTTP, la actualiza con los nuevos datos proporcionados en el cuerpo de la petición (body) y luego responde con un mensaje indicando que la reserva ha sido modificada con éxito.</p>

<hr>
<h3 id="controlador-reserva-eliminarReserva" class="mt-4">Controlador eliminarReserva</h3>
<p>Este código define una función eliminarReserva que se encarga de eliminar una reserva existente de la base de datos y eliminar las referencias de esta reserva en los libros y usuarios correspondientes.</p>
<pre><code>const eliminarReserva = async (req, res) => {
  const { id } = req.params;
  const reserva = await Reserva.findByIdAndDelete(id);
  await Libro.findByIdAndUpdate(reserva.idLibro, {
    $pull: { reservas: id },
  });
  await Usuario.findByIdAndUpdate(reserva.documento, {
    $pull: { reservas: id },
  });
  res.json({ mensaje: "Reserva eliminada", reserva });
};</code></pre>
<p>En resumen, este código busca una reserva en la base de datos utilizando el ID proporcionado en la URL de la petición HTTP, la elimina de la base de datos, elimina las referencias de esta reserva en los libros y usuarios correspondientes, y luego responde con un mensaje indicando que la reserva ha sido eliminada con éxito.</p>

<hr>
<h2 id="controlador-comentario" class="mt-4">Controladores de Prestamo</h2>
<p>En este apartado se definen los controladores para el manejo de los prestamos.</p>

<hr>
<h3 id="controlador-prestamo-crearPrestamo" class="mt-4">Controlador crearPrestamo</h3>
<p>Este código define una función crearPrestamo que se encarga de crear un nuevo préstamo de un libro en la base de datos y asociar este préstamo tanto al libro como al usuario correspondientes.</p>
<pre><code>const crearPrestamo = async (req, res) => {
  const { documento, idLibro, fechaDeInicio, fechaDeFin } = req.body;
  const prestamo = new Prestamo({
    documento,
    idLibro,
    fechaDeInicio,
    fechaDeFin,
  });
  await prestamo.save();
  await Libro.findByIdAndUpdate(idLibro, {
    $push: { prestamos: prestamo._id },
  });
  await Usuario.findByIdAndUpdate(documento, {
    $push: { prestamos: prestamo._id },
  });
  res.json({ mensaje: "Prestamo creado" });
};</code></pre>
<p>En resumen, este código crea un nuevo préstamo de un libro en la base de datos, asocia el préstamo tanto al libro como al usuario correspondientes mediante la actualización de sus respectivos arrays de préstamos, y luego responde con un mensaje indicando que el préstamo ha sido creado satisfactoriamente.</p>

<hr>
<h3 id="controlador-prestamo-verPrestamo" class="mt-4">Controlador verPrestamo</h3>
<p>Este código define una función verPrestamo que se encarga de buscar y mostrar un préstamo específico de la base de datos según el ID proporcionado en la URL de la petición HTTP.</p>
<pre><code>const verPrestamo = async (req, res) => {
  const { id } = req.params;
  const prestamo = await Prestamo.findById(id);
  res.json(prestamo);
};</code></pre>
<p>En resumen, este código busca un préstamo específico en la base de datos utilizando el ID proporcionado en la URL de la petición HTTP y luego responde con los datos de ese préstamo en formato JSON.</p>

<hr>
<h3 id="controlador-prestamo-verPrestamos" class="mt-4">Controlador verPrestamos</h3>
<p>Este código define una función verPrestamos que se encarga de buscar y mostrar todos los préstamos en la base de datos.</p>
<pre><code>const verPrestamos = async (req, res) => {
  const prestamos = await Prestamo.find();
  res.json(prestamos);
};</code></pre>
<p>En resumen, este código busca todos los préstamos en la base de datos y luego responde con los datos de todos los préstamos encontrados en formato JSON.</p>

<hr>
<h3 id="controlador-prestamo-editarPrestamo" class="mt-4">Controlador editarPrestamo</h3>
<p>Este código define una función editarPrestamo que se encarga de modificar un préstamo existente en la base de datos.</p>
<pre><code>const editarPrestamo = async (req, res) => {
  const { id } = req.params;
  const { idLibro, documento, fechaDeInicio, fechaDeFin } = req.body;
  const prestamo = await Prestamo.findByIdAndUpdate(id, {
    idLibro,
    documento,
    fechaDeInicio,
    fechaDeFin,
  });
  res.json({ mensaje: "Prestamo modificado", prestamo });
};</code></pre>
<p>En resumen, este código busca un préstamo en la base de datos utilizando el ID proporcionado en la URL de la petición HTTP, lo actualiza con los nuevos datos proporcionados en el cuerpo de la petición HTTP y luego responde con un mensaje indicando que el préstamo ha sido modificado con éxito.</p>

<hr>
<h3 id="controlador-prestamo-eliminarPrestamo" class="mt-4">Controlador eliminarPrestamo</h3>
<p>Este código define una función eliminarPrestamo que se encarga de eliminar un préstamo existente de la base de datos y eliminar las referencias de este préstamo en los libros y usuarios correspondientes.</p>
<pre><code>const eliminarPrestamo = async (req, res) => {
  const { id } = req.params;
  const prestamo = await Prestamo.findByIdAndDelete(id);
  await Libro.findByIdAndUpdate(prestamo.idLibro, {
    $pull: { prestamos: id },
  });
  await Usuario.findByIdAndUpdate(prestamo.documento, {
    $pull: { prestamos: id },
  });
  res.json({ mensaje: "Prestamo eliminado", prestamo });
};</code></pre>
<p>En resumen, este código busca un préstamo en la base de datos utilizando el ID proporcionado en la URL de la petición HTTP, lo elimina de la base de datos, elimina las referencias de este préstamo en los libros y usuarios correspondientes, y luego responde con un mensaje indicando que el préstamo ha sido eliminado con éxito.</p>

<hr>
<h2 id="rutas" class="mt-4">Rutas</h2>
<hr>
<p>Las rutas en un servidor son las URL específicas a las que el servidor puede responder. En ExpressJS, las rutas se definen mediante métodos de enrutamiento que toman como parámetros una URL (o un patrón de URL) y una función de controlador que se ejecuta cuando se realiza una solicitud a esa URL.</p>
<p><b><a href="https://expressjs.com/en/starter/basic-routing.html">Documentacion de rutas basica en ExpressJS</a></b></p>
<p><b><a href="https://expressjs.com/en/guide/routing.html">Documentacion de rutas extensa en ExpressJS</a></b></p>

<p>En las rutas se van a repetir frecuentemente los siguientes terminos, asi que vamos a explicarlos un poco.</p>
<p><b>catchAsync:</b> La función catchAsync se utiliza para envolver funciones asincrónicas en Express.js y manejar cualquier error que pueda ocurrir en ellas. Esto permite que los errores se manejen de manera centralizada en lugar de tener que manejarlos en cada función asincrónica individualmente.</p>
<pre><code>function catchAsync(fn) {
  return (req, res, next) => {
    fn(req, res, next).catch((err) => next(err));
  };
}</code></pre>

<br>

<p><b>Protocolo y Metodos HTTP:</b> El Protocolo de Transferencia de Hipertexto (HTTP) es un protocolo de red utilizado para transferir datos entre un cliente y un servidor a través de la web, este protocolo se utiliza para transmitir datos en forma de solicitudes y respuestas. <br>

  El protocolo HTTP se basa en la idea de solicitudes y respuestas, donde el cliente envía una solicitud al servidor y el servidor devuelve una respuesta. Las solicitudes y respuestas se componen de una serie de propiedades llamados <b>headers</b> y un cuerpo opcional <b>body</b> que contiene los datos que se envían entre el cliente y el servidor. <br>
  
  Las solicitudes HTTP se dividen en <b>métodos</b> como <b>GET</b> usado para recuperar información del servidor, <b>POST</b> para enviar datos al servidor, <b>PUT</b> para actualizar datos en el servidor, y <b>DELETE</b> para eliminar datos del servidor.</p>


<hr>
<h3 id="rutas-usuario" class="mt-4">Rutas de Usuario </h3>
<p>El siguiente código define un router para gestionar las rutas relacionadas con los usuarios en una aplicación utilizando Express.js. Define varias rutas para manejar operaciones CRUD y autenticación de usuarios en una aplicación Express.js. Utiliza middleware para validación, manejo de errores y autenticación.</p>

<pre><code>const routerUsuarios = require("express").Router();
  const {
    crearUsuario,
    buscarUsuario,
    verUsuarios,
    editarUsuario,
    eliminarUsuario,
    loginUsuario,
    desconectarUsuario,
    usuarioLogeado,
    errorLogin,
  } = require("../Controllers/usuario");
  const { catchAsync } = require("../middlewares");
  const {
    validarUsuario,
    validarEditarUsuario,
  } = require("../Validaciones/validaciones");
  const passport = require("passport");
  
  routerUsuarios
    .route("/")
    .get(catchAsync(verUsuarios))
    .post(validarUsuario, catchAsync(crearUsuario));
  
  // METODO Y RUTA PARA INICIAR SESION
  routerUsuarios.post(
    "/iniciar-sesion",
    passport.authenticate("local", {
      failureRedirect: "/api/usuarios/error-login",
    }),
    catchAsync(loginUsuario)
  );
  
  routerUsuarios.get("/desconectarse", catchAsync(desconectarUsuario));
  routerUsuarios.get("/usuario-logeado", catchAsync(usuarioLogeado));
  routerUsuarios.post("/error-login", catchAsync(errorLogin));
  
  routerUsuarios
    .route("/:id")
    .get(catchAsync(buscarUsuario))
    .put(validarEditarUsuario, catchAsync(editarUsuario))
    .delete(catchAsync(eliminarUsuario));
  
  module.exports = routerUsuarios;
  </code></pre>

<p>Las rutas creadas son las siguientes:</p>
<ul>
  <li>La ruta (“/”) escucha peticiones de metodos GET y POST. Una petición del metodo GET va a ejecutar el controlador verUsuarios y el POST ejecuta el controlador crearUsuario.</li>
  <li>La ruta (/iniciar-sesion) va a escuchar peticiones POST. Mediante la función “authenticate” de Passport va a realizar la autenticación del usuario y, si falla, redirige al usuario a la ruta “/api/usuarios/error-login”.</li>
  <li>Ruta (“/desconectarse”) escucha peticiones de métodos GET. La petición del metodo GET va a ejecutar el controlador desconectarUsuario.</li>
  <li>Ruta (“/usuario-logeado”) escucha peticiones de métodos GET. La petición del metodo GET va a ejecutar el controlador usuarioLogeado.</li>
  <li>Ruta (“/error-login”) va a escuchar peticiones de métodos POST. La petición del metodo POST va a ejecutar el controlador errorLogin.</li>
  <li>Ruta (“/:id”) va a escuchar peticiones de métodos GET, PUT y DELETE. La petición del metodo GET va a ejecutar el controlador buscarUsuario, la petición del metodo PUT va a ejecutar el controlador editarUsuario y la petición del metodo DELETE va a ejecutar el controlador elminarUsuario.</li>
</ul>

<hr>
<h3 id="rutas-libro" class="mt-4">Rutas de Libro </h3>
<p>El siguiente código define un router para gestionar las rutas relacionadas con los libros en una aplicación utilizando Express.js. Define varias rutas para manejar operaciones CRUD de libros en una aplicación Express.js. Utiliza middlewares para validación, manejo de errores, etc.</p>
<pre><code>const routerLibro = require("express").Router();
  const {
    crearLibro,
    buscarLibro,
    verLibros,
    modificarLibro,
    eliminarLibro,
  } = require("../Controllers/libro");
  
  const { catchAsync } = require("../middlewares");
  
  const {
    validarLibro,
    validarModificarLibro,
  } = require("../Validaciones/validaciones");
  
  routerLibro
    .route("/")
    .get(catchAsync(verLibros))
    .post(validarLibro, catchAsync(crearLibro));
  
  routerLibro
    .route("/:id")
    .get(catchAsync(buscarLibro))
    .put(validarModificarLibro, catchAsync(modificarLibro))
    .delete(catchAsync(eliminarLibro));
  
  module.exports = routerLibro;</code></pre>

<p>Las rutas creadas son las siguientes:</p>
<ul>
  <li>La ruta (“/”) escucha peticiones de métodos (HTTP) GET y POST. Una petición del metodo GET va a ejecutar el controlador verLibros y el POST ejecuta el controlador crearLibro.</li>
  <li>Ruta (“/:id”) va a escuchar peticiones de métodos GET, PUT y DELETE. La petición del metodo GET va a ejecutar el controlador buscarLibro, la petición del metodo PUT va a ejecutar el controlador modificarLibro y la petición del metodo DELETE va a ejecutar el controlador elminarLibro.</li>
</ul>

<hr>
<h3 id="rutas-comentario" class="mt-4">Rutas de Comentario </h3>
<p>El siguiente código define un router para gestionar las rutas relacionadas con los comentarios en una aplicación utilizando Express.js. Define varias rutas para manejar operaciones CRUD de comentarios en una aplicación Express.js. Utiliza middlewares para validación, manejo de errores, etc.</p>
<pre><code>const routerComentario = require("express").Router();
  const {
    crearComentario,
    modificarComentario,
    eliminarComentario,
    verComentario,
  } = require("../Controllers/comentario");
  
  const { catchAsync } = require("../middlewares");
  
  const {
    validarComentario,
    validarModificarComentario,
  } = require("../Validaciones/validaciones");
  
  routerComentario
    .route("/")
    .post(validarComentario, catchAsync(crearComentario));
  
  routerComentario
    .route("/:id")
    .get(catchAsync(verComentario))
    .put(validarModificarComentario, catchAsync(modificarComentario))
    .delete(catchAsync(eliminarComentario));
  
  module.exports = routerComentario;</code></pre>

  <p>Las rutas creadas son las siguientes:</p>
  <ul>
    <li>La ruta (“/”) escucha peticiones de métodos POST. Una petición del metodo POST ejecuta el controlador crearComentario.</li>
    <li>Ruta (“/:id”) va a escuchar peticiones de métodos GET, PUT y DELETE. La petición del metodo GET va a ejecutar el controlador verComentario, la petición del metodo PUT va a ejecutar el controlador modificarComentario y la petición del metodo DELETE va a ejecutar el controlador elminarComentario.</li>
  </ul>

<hr>
<h3 id="rutas-reserva" class="mt-4">Rutas de Reserva </h3>
<p>El siguiente código define un router para gestionar las rutas relacionadas con las reservas en una aplicación utilizando Express.js. Define varias rutas para manejar operaciones CRUD de reserva en una aplicación Express.js. Utiliza middlewares para validación, manejo de errores, etc.</p>
<pre><code>const RouterReservas = require("express").Router();
  const {
    crearReserva,
    verReserva,
    verReservas,
    editarReserva,
    eliminarReserva,
  } = require("../Controllers/reserva");
  const { catchAsync } = require("../middlewares");
  const {
    validarReserva,
    validarEditarReserva,
  } = require("../Validaciones/validaciones");
  
  RouterReservas.route("/")
    .post(validarReserva, catchAsync(crearReserva))
    .get(catchAsync(verReservas));
  
  RouterReservas.route("/:id")
    .get(catchAsync(verReserva))
    .put(validarEditarReserva, catchAsync(editarReserva))
    .delete(catchAsync(eliminarReserva));
  module.exports = RouterReservas;</code></pre>
<p>Las rutas creadas son las siguientes:</p>
<ul>
  <li>La ruta (“/”) escucha peticiones de métodos POST y GET. Una petición del metodo POST ejecuta el controlador crearReserva y una petición del metodo GET ejecuta el controlador verReservas.</li>
  <li>Ruta (“/:id”) va a escuchar peticiones de métodos GET, PUT y DELETE. La petición del metodo GET va a ejecutar el controlador verReserva, la petición del metodo PUT va a ejecutar el controlador editarReserva y la petición del metodo DELETE va a ejecutar el controlador elminarReserva.</li>
</ul>

<hr>
<h3 id="rutas-prestamo" class="mt-4">Rutas de Prestamo </h3>
<p>El siguiente código define un router para gestionar las rutas relacionadas con los préstamos en una aplicación utilizando Express.js. Define varias rutas para manejar operaciones CRUD de préstamos en una aplicación Express.js. Utiliza middlewares para validación, manejo de errores, etc.</p>
<pre><code>const RouterPrestamos = require("express").Router();
  const {
    crearPrestamo,
    verPrestamo,
    verPrestamos,
    editarPrestamo,
    eliminarPrestamo,
  } = require("../Controllers/prestamo");
  const { catchAsync } = require("../middlewares");
  const {
    validarPrestamo,
    validarEditarPrestamo,
  } = require("../Validaciones/validaciones");
  
  RouterPrestamos.route("/")
    .post(validarPrestamo, catchAsync(crearPrestamo))
    .get(catchAsync(verPrestamos));
  
  RouterPrestamos.route("/:id")
    .get(catchAsync(verPrestamo))
    .put(validarEditarPrestamo, catchAsync(editarPrestamo))
    .delete(catchAsync(eliminarPrestamo));
  module.exports = RouterPrestamos;</code></pre>
<p>Las rutas creadas son las siguientes:</p>
<ul>
  <li>La ruta (“/”) escucha peticiones de métodos POST y GET. Una petición del metodo POST ejecuta el controlador crearPrestamo y una petición del metodo GET ejecuta el controlador verPrestamos.</li>
  <li>Ruta (“/:id”) va a escuchar peticiones de métodos GET, PUT y DELETE. La petición del metodo GET va a ejecutar el controlador verPrestamo, la petición del metodo PUT va a ejecutar el controlador editarPrestamo y la petición del metodo DELETE va a ejecutar el controlador elminarPrestamo.</li>
</ul>

<hr>

<h2 id="esquemas-validaciones" class="mt-4">Esquemas para validaciones</h2>
<hr>
<p>Un esquema de validación de datos en una base de datos es un conjunto de reglas y restricciones que se aplican a los datos almacenados en la base de datos. Se utiliza validar los datos de las solicitudes entrantes y asegurar que cumplan con los requisitos esperados antes de proceder con la lógica del negocio. El uso de esquemas de validación en una base de datos ayuda a prevenir la entrada de datos no válidos, lo que puede evitar problemas como datos duplicados, datos incompletos o datos que no cumplan con los requisitos de negocio.</p>

<p><b>Joi:</b> Es una biblioteca de validación de esquemas en JavaScript que se utiliza comúnmente en el contexto de validaciones de datos en bases de datos. <br>
<b>Required():</b> Es un metodo de de Joi que se utiliza para indicar que un campo es obligatorio.</p>

<hr>
<h3 id="esquemas-esquemaUsuario" class="mt-4">esquemaUsuario </h3>
<p>El siguiente código define un esquema de validación para los datos que debe contener un usuario para ser creado.</p>
<pre><code>const esquemaUsuario = Joi.object({
  dni: Joi.number().required(),
  nombre: Joi.string().required(),
  apellido: Joi.string().required(),
  email: Joi.string().email().required(),
  rol: Joi.string(),
  password: Joi.string().required(),
  activo: Joi.boolean(),
});</code></pre>
<p>
  Campos:
  <ul>
    <li><b>dni:</b> Numero, requerido.</li>
    <li><b>nombre:</b> Cadena de texto, requerido.</li>
    <li><b>apellido:</b> Cadena de texto, requerido.</li>
    <li><b>email:</b> Cadena de texto con formato de email, requerido.</li>
    <li><b>rol:</b> Cadena de texto.</li>
    <li><b>password:</b> Cadena de texto, requerido.</li>
    <li><b>activo:</b> Booleano.</li>
  </ul>
</p>

<hr>
<h3 id="esquemas-esquemaEditarUsuario" class="mt-4">esquemaEditarUsuario </h3>
<p>El siguiente código define un esquema de validación para los datos que debe contener un usuario para ser modificado.</p>
<pre><code>const esquemaEditarUsuario = Joi.object({
  dni: Joi.number(),
  nombre: Joi.string().required(),
  apellido: Joi.string().required(),
  email: Joi.string().email().required(),
  rol: Joi.string(),
  password: Joi.string(),
  activo: Joi.boolean(),
});</code></pre>
<p>
  Campos:
  <ul>
    <li><b>dni:</b> Numero.</li>
    <li><b>nombre:</b> Cadena de texto, requerido.</li>
    <li><b>apellido:</b> Cadena de texto, requerido.</li>
    <li><b>email:</b> Cadena de texto con formato de email, requerido.</li>
    <li><b>rol:</b> Cadena de texto.</li>
    <li><b>password:</b> Cadena de texto.</li>
    <li><b>activo:</b> Booleano.</li>
  </ul>
</p>

<hr>
<h3 id="esquemas-esquemaLibro" class="mt-4">esquemaLibro </h3>
<p>El siguiente código define un esquema de validación para los datos que debe contener un libro para ser creado.</p>
<pre><code>const esquemaLibro = Joi.object({
  titulo: Joi.string().required(),
  autor: Joi.string().required(),
  categoria: Joi.string().required(),
  copiaVirtual: Joi.string().required(),
  copiasLibro: Joi.number().min(0).required(),
  comentarios: Joi.array(),
  descripcion: Joi.string().required(),
  imagen: Joi.string(),
});</code></pre>
<p>
  Campos:
  <ul>
    <li><b>titulo:</b> Cadena de texto, requerido.</li>
    <li><b>autor:</b> Cadena de texto, requerido.</li>
    <li><b>categoria:</b> Cadena de texto, requerido.</li>
    <li><b>copiaVirtual:</b> Cadena de texto, requerido.</li>
    <li><b>copiasLibro:</b> Numero mayor o igual a 0, requerido.</li>
    <li><b>comentarios:</b> Array. (de IDs)</li>
    <li><b>descripcion:</b> Cadena de texto, requerido.</li>
    <li><b>imagen:</b> Cadena de texto. (URL)</li>
  </ul>
</p>

<hr>
<h3 id="esquemas-esquemaModificarLibro" class="mt-4">esquemaModificarLibro </h3>
<p>El siguiente código define un esquema de validación para los datos que debe contener un libro para ser modificado.</p>
<pre><code>const esquemaModificarLibro = Joi.object({
  titulo: Joi.string().required(),
  autor: Joi.string().required(),
  categoria: Joi.string().required(),
  copiaVirtual: Joi.string(),
  copiasLibro: Joi.number().required(),
  comentarios: Joi.array(),
  descripcion: Joi.string().required(),
  imagen: Joi.string(),
});</code></pre>
<p>
  Campos:
  <ul>
    <li><b>titulo:</b> Cadena de texto, requerido.</li>
    <li><b>autor:</b> Cadena de texto, requerido.</li>
    <li><b>categoria:</b> Cadena de texto, requerido.</li>
    <li><b>copiaVirtual:</b> Cadena de texto.</li>
    <li><b>copiasLibro:</b> Numero, requerido.</li>
    <li><b>comentarios:</b> Array. (de IDs)</li>
    <li><b>descripcion:</b> Cadena de texto, requerido.</li>
    <li><b>imagen:</b> Cadena de texto. (URL)</li>
  </ul>
</p>

<hr>
<h3 id="esquemas-esquemaComentario" class="mt-4">esquemaComentario</h3>
<p>El siguiente código define un esquema de validación para los datos que debe contener un comentario para ser creado.</p>
<pre><code>const esquemaComentario = Joi.object({
  idLibro: Joi.string().required(),
  documento: Joi.string().required(),
  textoComentario: Joi.string().required(),
  puntuacion: Joi.number().required(),
});</code></pre>
<p>
  Campos:
  <ul>
    <li><b>idLibro:</b> Cadena de texto, requerido.</li>
    <li><b>documento:</b> Cadena de texto, requerido.</li>
    <li><b>textoComentario:</b> Cadena de texto, requerido.</li>
    <li><b>puntuacion:</b> Numero, requerido.</li>
  </ul>
</p>

<hr>
<h3 id="esquemas-esquemaModificarComentario" class="mt-4">esquemaModificarComentario</h3>
<p>El siguiente código define un esquema de validación para los datos que debe contener un comentario para ser modificado.</p>
<pre><code>const esquemaModificarComentario = Joi.object({
  idLibro: Joi.string(),
  documento: Joi.string(),
  textoComentario: Joi.string().required(),
  puntuacion: Joi.number().required(),
});</code></pre>
<p>
  Campos:
  <ul>
    <li><b>idLibro:</b> Cadena de texto.</li>
    <li><b>documento:</b> Cadena de texto.</li>
    <li><b>textoComentario:</b> Cadena de texto, requerido.</li>
    <li><b>puntuacion:</b> Numero, requerido.</li>
  </ul>
</p>

<hr>
<h3 id="esquemas-esquemaReserva" class="mt-4">esquemaReserva</h3>
<p>El siguiente código define un esquema de validación para los datos que debe contener una reserva para ser creada.</p>
<pre><code>const esquemaReserva = Joi.object({
  idLibro: Joi.string().required(),
  documento: Joi.string().required(),
  fechaReserva: Joi.date().required(),
  fechaDevolucion: Joi.date().required(),
  estadoReserva: Joi.boolean(),
});</code></pre>
<p>
  Campos:
  <ul>
    <li><b>idLibro:</b> Cadena de texto, requerido.</li>
    <li><b>documento:</b> Cadena de texto, requerido.</li>
    <li><b>fechaReserva:</b> Fecha, requerido.</li>
    <li><b>fechaDevolucion:</b> Fecha, requerido.</li>
    <li><b>estadoReserva:</b> Booleano.</li>
  </ul>
</p>

<hr>
<h3 id="esquemas-esquemaEditarReserva" class="mt-4">esquemaEditarReserva</h3>
<p>El siguiente código define un esquema de validación para los datos que debe contener una reserva para ser modificada.</p>
<pre><code>const esquemaEditarReserva = Joi.object({
  idLibro: Joi.string(),
  documento: Joi.string(),
  fechaReserva: Joi.date().required(),
  fechaDevolucion: Joi.date().required(),
  estadoReserva: Joi.boolean(),
});</code></pre>
<p>
  Campos:
  <ul>
    <li><b>idLibro:</b> Cadena de texto.</li>
    <li><b>documento:</b> Cadena de texto.</li>
    <li><b>fechaReserva:</b> Fecha, requerido.</li>
    <li><b>fechaDevolucion:</b> Fecha, requerido.</li>
    <li><b>estadoReserva:</b> Booleano.</li>
  </ul>
</p>

<hr>
<h3 id="esquemas-esquemaPrestamo" class="mt-4">esquemaPrestamo</h3>
<p>El siguiente código define un esquema de validación para los datos que debe contener un prestamo para ser creado.</p>
<pre><code>const esquemaPrestamo = Joi.object({
  idLibro: Joi.string().required(),
  documento: Joi.string().required(),
  fechaDeInicio: Joi.date().required(),
  fechaDeFin: Joi.date().required(),
  fechaDevolucion: Joi.boolean(),
});</code></pre>
<p>
  Campos:
  <ul>
    <li><b>idLibro:</b> Cadena de texto, requerido.</li>
    <li><b>documento:</b> Cadena de texto, requerido.</li>
    <li><b>fechaDeInicio:</b> Fecha, requerido.</li>
    <li><b>fechaDeFin:</b> Fecha, requerido.</li>
    <li><b>fechaDevolucion:</b> Booleano.</li>
  </ul>
</p>

<hr>
<h3 id="esquemas-esquemaEditarPrestamo" class="mt-4">esquemaEditarPrestamo</h3>
<p>El siguiente código define un esquema de validación para los datos que debe contener un prestamo para ser modificado.</p>
<pre><code>const esquemaEditarPrestamo = Joi.object({
  idLibro: Joi.string(),
  documento: Joi.string(),
  fechaDeInicio: Joi.date().required(),
  fechaDeFin: Joi.date().required(),
  fechaDevolucion: Joi.boolean(),
});</code></pre>
<p>
  Campos:
  <ul>
    <li><b>idLibro:</b> Cadena de texto.</li>
    <li><b>documento:</b> Cadena de texto.</li>
    <li><b>fechaDeInicio:</b> Fecha, requerido.</li>
    <li><b>fechaDeFin:</b> Fecha, requerido.</li>
    <li><b>fechaDevolucion:</b> Booleano.</li>
  </ul>
</p>

</div>
      </div>
    </div>
  </body>
</html>
